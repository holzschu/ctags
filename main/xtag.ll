; ModuleID = 'xtag.c'
source_filename = "xtag.c"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "arm64-apple-ios11.0.0"

%struct.sXtagObject = type { %struct.sXtagDefinition*, i32, i32 }
%struct.sXtagDefinition = type { i8, i8, i8*, i8*, i1 (%struct.sXtagDefinition*)*, i1 (%struct.sXtagDefinition*)*, i32 }
%struct.colprintTable = type opaque
%struct.colprintLine = type opaque
%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sFILEX = type opaque
%struct.__sbuf = type { i8*, i32 }
%struct.sTrashBox = type opaque

@.str = private unnamed_addr constant [9 x i8] c"L:LETTER\00", align 1
@.str.1 = private unnamed_addr constant [7 x i8] c"L:NAME\00", align 1
@.str.2 = private unnamed_addr constant [10 x i8] c"L:ENABLED\00", align 1
@.str.3 = private unnamed_addr constant [11 x i8] c"L:LANGUAGE\00", align 1
@.str.4 = private unnamed_addr constant [8 x i8] c"L:FIXED\00", align 1
@.str.5 = private unnamed_addr constant [14 x i8] c"L:DESCRIPTION\00", align 1
@xtagObjectUsed = internal global i32 0, align 4
@xtagObjectAllocated = internal global i32 0, align 4
@xtagObjects = internal global %struct.sXtagObject* null, align 8
@xtagDefinitions = internal global [8 x %struct.sXtagDefinition] [%struct.sXtagDefinition { i8 1, i8 70, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.9, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)* null, i32 0 }, %struct.sXtagDefinition { i8 0, i8 102, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.11, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)* null, i32 0 }, %struct.sXtagDefinition { i8 0, i8 112, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.13, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* @isPseudoTagsEnabled, i1 (%struct.sXtagDefinition*)* @isPseudoTagsFixed, i32 0 }, %struct.sXtagDefinition { i8 0, i8 113, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.15, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)* null, i32 0 }, %struct.sXtagDefinition { i8 0, i8 114, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.17, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)* null, i32 0 }, %struct.sXtagDefinition { i8 0, i8 103, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.19, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)* null, i32 0 }, %struct.sXtagDefinition { i8 1, i8 115, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.21, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)* null, i32 0 }, %struct.sXtagDefinition { i8 0, i8 0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([95 x i8], [95 x i8]* @.str.23, i32 0, i32 0), i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)* null, i32 0 }], align 8
@.str.6 = private unnamed_addr constant [28 x i8] c"Add extra[%d]: %s,%s in %s\0A\00", align 1
@getXtagTypeGeneric.initialized = internal global i8 0, align 1
@.str.7 = private unnamed_addr constant [5 x i8] c"NONE\00", align 1
@.str.8 = private unnamed_addr constant [10 x i8] c"fileScope\00", align 1
@.str.9 = private unnamed_addr constant [27 x i8] c"Include tags of file scope\00", align 1
@.str.10 = private unnamed_addr constant [10 x i8] c"inputFile\00", align 1
@.str.11 = private unnamed_addr constant [60 x i8] c"Include an entry for the base file name of every input file\00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"pseudo\00", align 1
@.str.13 = private unnamed_addr constant [20 x i8] c"Include pseudo tags\00", align 1
@.str.14 = private unnamed_addr constant [10 x i8] c"qualified\00", align 1
@.str.15 = private unnamed_addr constant [56 x i8] c"Include an extra class-qualified tag entry for each tag\00", align 1
@.str.16 = private unnamed_addr constant [10 x i8] c"reference\00", align 1
@.str.17 = private unnamed_addr constant [23 x i8] c"Include reference tags\00", align 1
@.str.18 = private unnamed_addr constant [6 x i8] c"guest\00", align 1
@.str.19 = private unnamed_addr constant [40 x i8] c"Include tags generated by guest parsers\00", align 1
@.str.20 = private unnamed_addr constant [10 x i8] c"subparser\00", align 1
@.str.21 = private unnamed_addr constant [37 x i8] c"Include tags generated by subparsers\00", align 1
@.str.22 = private unnamed_addr constant [8 x i8] c"subword\00", align 1
@.str.23 = private unnamed_addr constant [95 x i8] c"Include tags for subwords generated by splitting the original tag (only for ctags development)\00", align 1

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.sXtagDefinition* @getXtagDefinition(i32 %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i32, i32* %type.addr, align 4
  %call = call %struct.sXtagObject* @getXtagObject(i32 %0)
  %def = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %call, i32 0, i32 0
  %1 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  ret %struct.sXtagDefinition* %1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal %struct.sXtagObject* @getXtagObject(i32 %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.sXtagObject*, %struct.sXtagObject** @xtagObjects, align 8
  %1 = load i32, i32* %type.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %0, i64 %idx.ext
  ret %struct.sXtagObject* %add.ptr
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @getXtagTypeForLetter(i8 signext %letter) #0 {
entry:
  %letter.addr = alloca i8, align 1
  store i8 %letter, i8* %letter.addr, align 1
  %call = call i32 @getXtagTypeGeneric(i1 (%struct.sXtagObject*, i32, i8*)* @xtagEqualByLetter, i32 -2, i8* %letter.addr)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @getXtagTypeGeneric(i1 (%struct.sXtagObject*, i32, i8*)* %predicate, i32 %language, i8* %user_data) #0 {
entry:
  %retval = alloca i32, align 4
  %predicate.addr = alloca i1 (%struct.sXtagObject*, i32, i8*)*, align 8
  %language.addr = alloca i32, align 4
  %user_data.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  store i1 (%struct.sXtagObject*, i32, i8*)* %predicate, i1 (%struct.sXtagObject*, i32, i8*)** %predicate.addr, align 8
  store i32 %language, i32* %language.addr, align 4
  store i8* %user_data, i8** %user_data.addr, align 8
  %0 = load i32, i32* %language.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @getXtagTypeGeneric.initialized, align 1
  %tobool = trunc i8 %1 to i1
  %conv = zext i1 %tobool to i32
  %cmp1 = icmp eq i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i8 1, i8* @getXtagTypeGeneric.initialized, align 1
  call void @initializeParser(i32 -1)
  br label %if.end11

if.else:                                          ; preds = %land.lhs.true, %entry
  %2 = load i32, i32* %language.addr, align 4
  %cmp3 = icmp ne i32 %2, -2
  br i1 %cmp3, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %if.else
  %3 = load i8, i8* @getXtagTypeGeneric.initialized, align 1
  %tobool6 = trunc i8 %3 to i1
  %conv7 = zext i1 %tobool6 to i32
  %cmp8 = icmp eq i32 %conv7, 0
  br i1 %cmp8, label %if.then10, label %if.end

if.then10:                                        ; preds = %land.lhs.true5
  %4 = load i32, i32* %language.addr, align 4
  call void @initializeParser(i32 %4)
  br label %if.end

if.end:                                           ; preds = %if.then10, %land.lhs.true5, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* @xtagObjectUsed, align 4
  %cmp12 = icmp ult i32 %5, %6
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i1 (%struct.sXtagObject*, i32, i8*)*, i1 (%struct.sXtagObject*, i32, i8*)** %predicate.addr, align 8
  %8 = load %struct.sXtagObject*, %struct.sXtagObject** @xtagObjects, align 8
  %9 = load i32, i32* %i, align 4
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %8, i64 %idx.ext
  %10 = load i32, i32* %language.addr, align 4
  %11 = load i8*, i8** %user_data.addr, align 8
  %call = call zeroext i1 %7(%struct.sXtagObject* %add.ptr, i32 %10, i8* %11)
  br i1 %call, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %13 = load i32, i32* %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then14
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @xtagEqualByLetter(%struct.sXtagObject* %pobj, i32 %language, i8* %user_data) #0 {
entry:
  %pobj.addr = alloca %struct.sXtagObject*, align 8
  %language.addr = alloca i32, align 4
  %user_data.addr = alloca i8*, align 8
  store %struct.sXtagObject* %pobj, %struct.sXtagObject** %pobj.addr, align 8
  store i32 %language, i32* %language.addr, align 4
  store i8* %user_data, i8** %user_data.addr, align 8
  %0 = load %struct.sXtagObject*, %struct.sXtagObject** %pobj.addr, align 8
  %def = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %0, i32 0, i32 0
  %1 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %letter = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %1, i32 0, i32 1
  %2 = load i8, i8* %letter, align 1
  %conv = zext i8 %2 to i32
  %3 = load i8*, i8** %user_data.addr, align 8
  %4 = load i8, i8* %3, align 1
  %conv1 = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, %conv1
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 1, i32 0
  %tobool = icmp ne i32 %cond, 0
  ret i1 %tobool
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @getXtagTypeForNameAndLanguage(i8* %name, i32 %language) #0 {
entry:
  %name.addr = alloca i8*, align 8
  %language.addr = alloca i32, align 4
  store i8* %name, i8** %name.addr, align 8
  store i32 %language, i32* %language.addr, align 4
  %0 = load i32, i32* %language.addr, align 4
  %1 = load i8*, i8** %name.addr, align 8
  %call = call i32 @getXtagTypeGeneric(i1 (%struct.sXtagObject*, i32, i8*)* @xtagEqualByNameAndLanguage, i32 %0, i8* %1)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @xtagEqualByNameAndLanguage(%struct.sXtagObject* %pobj, i32 %language, i8* %user_data) #0 {
entry:
  %retval = alloca i1, align 1
  %pobj.addr = alloca %struct.sXtagObject*, align 8
  %language.addr = alloca i32, align 4
  %user_data.addr = alloca i8*, align 8
  %name = alloca i8*, align 8
  store %struct.sXtagObject* %pobj, %struct.sXtagObject** %pobj.addr, align 8
  store i32 %language, i32* %language.addr, align 4
  store i8* %user_data, i8** %user_data.addr, align 8
  %0 = load i8*, i8** %user_data.addr, align 8
  store i8* %0, i8** %name, align 8
  %1 = load i32, i32* %language.addr, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.sXtagObject*, %struct.sXtagObject** %pobj.addr, align 8
  %language1 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %2, i32 0, i32 1
  %3 = load i32, i32* %language1, align 8
  %4 = load i32, i32* %language.addr, align 4
  %cmp2 = icmp eq i32 %3, %4
  br i1 %cmp2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %5 = load %struct.sXtagObject*, %struct.sXtagObject** %pobj.addr, align 8
  %def = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %5, i32 0, i32 0
  %6 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %name3 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %6, i32 0, i32 2
  %7 = load i8*, i8** %name3, align 8
  %8 = load i8*, i8** %name, align 8
  %call = call i32 @strcmp(i8* %7, i8* %8)
  %cmp4 = icmp eq i32 %call, 0
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then
  %9 = load i1, i1* %retval, align 1
  ret i1 %9
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define %struct.colprintTable* @xtagColprintTableNew() #0 {
entry:
  %call = call %struct.colprintTable* (i8*, ...) @colprintTableNew(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i64 0, i64 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i64 0, i64 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3, i64 0, i64 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.4, i64 0, i64 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.5, i64 0, i64 0), i8* null)
  ret %struct.colprintTable* %call
}

declare %struct.colprintTable* @colprintTableNew(i8*, ...) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @xtagColprintAddCommonLines(%struct.colprintTable* %table) #0 {
entry:
  %table.addr = alloca %struct.colprintTable*, align 8
  %i = alloca i32, align 4
  store %struct.colprintTable* %table, %struct.colprintTable** %table.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.colprintTable*, %struct.colprintTable** %table.addr, align 8
  %2 = load i32, i32* %i, align 4
  call void @xtagColprintAddLine(%struct.colprintTable* %1, i32 %2)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, i32* %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @xtagColprintAddLine(%struct.colprintTable* %table, i32 %xtype) #0 {
entry:
  %table.addr = alloca %struct.colprintTable*, align 8
  %xtype.addr = alloca i32, align 4
  %xobj = alloca %struct.sXtagObject*, align 8
  %xdef = alloca %struct.sXtagDefinition*, align 8
  %line = alloca %struct.colprintLine*, align 8
  store %struct.colprintTable* %table, %struct.colprintTable** %table.addr, align 8
  store i32 %xtype, i32* %xtype.addr, align 4
  %0 = load i32, i32* %xtype.addr, align 4
  %call = call %struct.sXtagObject* @getXtagObject(i32 %0)
  store %struct.sXtagObject* %call, %struct.sXtagObject** %xobj, align 8
  %1 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %def = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %1, i32 0, i32 0
  %2 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  store %struct.sXtagDefinition* %2, %struct.sXtagDefinition** %xdef, align 8
  %3 = load %struct.colprintTable*, %struct.colprintTable** %table.addr, align 8
  %call1 = call %struct.colprintLine* @colprintTableGetNewLine(%struct.colprintTable* %3)
  store %struct.colprintLine* %call1, %struct.colprintLine** %line, align 8
  %4 = load %struct.colprintLine*, %struct.colprintLine** %line, align 8
  %5 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %xdef, align 8
  %letter = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %5, i32 0, i32 1
  %6 = load i8, i8* %letter, align 1
  %conv = zext i8 %6 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %xdef, align 8
  %letter3 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %7, i32 0, i32 1
  %8 = load i8, i8* %letter3, align 1
  %conv4 = zext i8 %8 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 45, %cond.true ], [ %conv4, %cond.false ]
  %conv5 = trunc i32 %cond to i8
  call void @colprintLineAppendColumnChar(%struct.colprintLine* %4, i8 signext %conv5)
  %9 = load %struct.colprintLine*, %struct.colprintLine** %line, align 8
  %10 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %xdef, align 8
  %name = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %10, i32 0, i32 2
  %11 = load i8*, i8** %name, align 8
  call void @colprintLineAppendColumnCString(%struct.colprintLine* %9, i8* %11)
  %12 = load %struct.colprintLine*, %struct.colprintLine** %line, align 8
  %13 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %xdef, align 8
  %xtype6 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %13, i32 0, i32 6
  %14 = load i32, i32* %xtype6, align 8
  %call7 = call zeroext i1 @isXtagEnabled(i32 %14)
  call void @colprintLineAppendColumnBool(%struct.colprintLine* %12, i1 zeroext %call7)
  %15 = load %struct.colprintLine*, %struct.colprintLine** %line, align 8
  %16 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %language = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %16, i32 0, i32 1
  %17 = load i32, i32* %language, align 8
  %cmp8 = icmp eq i32 %17, -2
  br i1 %cmp8, label %cond.true10, label %cond.false11

cond.true10:                                      ; preds = %cond.end
  br label %cond.end14

cond.false11:                                     ; preds = %cond.end
  %18 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %language12 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %18, i32 0, i32 1
  %19 = load i32, i32* %language12, align 8
  %call13 = call i8* @getLanguageName(i32 %19)
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false11, %cond.true10
  %cond15 = phi i8* [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i64 0, i64 0), %cond.true10 ], [ %call13, %cond.false11 ]
  call void @colprintLineAppendColumnCString(%struct.colprintLine* %15, i8* %cond15)
  %20 = load %struct.colprintLine*, %struct.colprintLine** %line, align 8
  %21 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %xdef, align 8
  %xtype16 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %21, i32 0, i32 6
  %22 = load i32, i32* %xtype16, align 8
  %call17 = call zeroext i1 @isXtagFixed(i32 %22)
  call void @colprintLineAppendColumnBool(%struct.colprintLine* %20, i1 zeroext %call17)
  %23 = load %struct.colprintLine*, %struct.colprintLine** %line, align 8
  %24 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %xdef, align 8
  %description = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %24, i32 0, i32 3
  %25 = load i8*, i8** %description, align 8
  call void @colprintLineAppendColumnCString(%struct.colprintLine* %23, i8* %25)
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @xtagColprintAddLanguageLines(%struct.colprintTable* %table, i32 %language) #0 {
entry:
  %table.addr = alloca %struct.colprintTable*, align 8
  %language.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %xobj = alloca %struct.sXtagObject*, align 8
  store %struct.colprintTable* %table, %struct.colprintTable** %table.addr, align 8
  store i32 %language, i32* %language.addr, align 4
  store i32 8, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @xtagObjectUsed, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %call = call %struct.sXtagObject* @getXtagObject(i32 %2)
  store %struct.sXtagObject* %call, %struct.sXtagObject** %xobj, align 8
  %3 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %language1 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %3, i32 0, i32 1
  %4 = load i32, i32* %language1, align 8
  %5 = load i32, i32* %language.addr, align 4
  %cmp2 = icmp eq i32 %4, %5
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load %struct.colprintTable*, %struct.colprintTable** %table.addr, align 8
  %7 = load i32, i32* %i, align 4
  call void @xtagColprintAddLine(%struct.colprintTable* %6, i32 %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @xtagColprintTablePrint(%struct.colprintTable* %table, i1 zeroext %withListHeader, i1 zeroext %machinable, %struct.__sFILE* %fp) #0 {
entry:
  %table.addr = alloca %struct.colprintTable*, align 8
  %withListHeader.addr = alloca i8, align 1
  %machinable.addr = alloca i8, align 1
  %fp.addr = alloca %struct.__sFILE*, align 8
  store %struct.colprintTable* %table, %struct.colprintTable** %table.addr, align 8
  %frombool = zext i1 %withListHeader to i8
  store i8 %frombool, i8* %withListHeader.addr, align 1
  %frombool1 = zext i1 %machinable to i8
  store i8 %frombool1, i8* %machinable.addr, align 1
  store %struct.__sFILE* %fp, %struct.__sFILE** %fp.addr, align 8
  %0 = load %struct.colprintTable*, %struct.colprintTable** %table.addr, align 8
  call void @colprintTableSort(%struct.colprintTable* %0, i32 (%struct.colprintLine*, %struct.colprintLine*)* @xtagColprintCompareLines)
  %1 = load %struct.colprintTable*, %struct.colprintTable** %table.addr, align 8
  %2 = load i8, i8* %withListHeader.addr, align 1
  %tobool = trunc i8 %2 to i1
  %3 = load i8, i8* %machinable.addr, align 1
  %tobool2 = trunc i8 %3 to i1
  %4 = load %struct.__sFILE*, %struct.__sFILE** %fp.addr, align 8
  call void @colprintTablePrint(%struct.colprintTable* %1, i32 0, i1 zeroext %tobool, i1 zeroext %tobool2, %struct.__sFILE* %4)
  ret void
}

declare void @colprintTableSort(%struct.colprintTable*, i32 (%struct.colprintLine*, %struct.colprintLine*)*) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal i32 @xtagColprintCompareLines(%struct.colprintLine* %a, %struct.colprintLine* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.colprintLine*, align 8
  %b.addr = alloca %struct.colprintLine*, align 8
  %a_parser = alloca i8*, align 8
  %b_parser = alloca i8*, align 8
  %r = alloca i32, align 4
  %a_name = alloca i8*, align 8
  %b_name = alloca i8*, align 8
  %a_letter = alloca i8*, align 8
  %b_letter = alloca i8*, align 8
  store %struct.colprintLine* %a, %struct.colprintLine** %a.addr, align 8
  store %struct.colprintLine* %b, %struct.colprintLine** %b.addr, align 8
  %0 = load %struct.colprintLine*, %struct.colprintLine** %a.addr, align 8
  %call = call i8* @colprintLineGetColumn(%struct.colprintLine* %0, i32 3)
  store i8* %call, i8** %a_parser, align 8
  %1 = load %struct.colprintLine*, %struct.colprintLine** %b.addr, align 8
  %call1 = call i8* @colprintLineGetColumn(%struct.colprintLine* %1, i32 3)
  store i8* %call1, i8** %b_parser, align 8
  %2 = load i8*, i8** %a_parser, align 8
  %call2 = call i32 @strcmp(i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i64 0, i64 0))
  %cmp = icmp eq i32 %call2, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load i8*, i8** %b_parser, align 8
  %call3 = call i32 @strcmp(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i64 0, i64 0))
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i32 -1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %4 = load i8*, i8** %a_parser, align 8
  %call5 = call i32 @strcmp(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i64 0, i64 0))
  %cmp6 = icmp ne i32 %call5, 0
  br i1 %cmp6, label %land.lhs.true7, label %if.else11

land.lhs.true7:                                   ; preds = %if.else
  %5 = load i8*, i8** %b_parser, align 8
  %call8 = call i32 @strcmp(i8* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i64 0, i64 0))
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %land.lhs.true7
  store i32 1, i32* %retval, align 4
  br label %return

if.else11:                                        ; preds = %land.lhs.true7, %if.else
  %6 = load i8*, i8** %a_parser, align 8
  %call12 = call i32 @strcmp(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i64 0, i64 0))
  %cmp13 = icmp ne i32 %call12, 0
  br i1 %cmp13, label %land.lhs.true14, label %if.else24

land.lhs.true14:                                  ; preds = %if.else11
  %7 = load i8*, i8** %b_parser, align 8
  %call15 = call i32 @strcmp(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i64 0, i64 0))
  %cmp16 = icmp ne i32 %call15, 0
  br i1 %cmp16, label %if.then17, label %if.else24

if.then17:                                        ; preds = %land.lhs.true14
  %8 = load i8*, i8** %a_parser, align 8
  %9 = load i8*, i8** %b_parser, align 8
  %call18 = call i32 @strcmp(i8* %8, i8* %9)
  store i32 %call18, i32* %r, align 4
  %10 = load i32, i32* %r, align 4
  %cmp19 = icmp ne i32 %10, 0
  br i1 %cmp19, label %if.then20, label %if.end

if.then20:                                        ; preds = %if.then17
  %11 = load i32, i32* %r, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then17
  %12 = load %struct.colprintLine*, %struct.colprintLine** %a.addr, align 8
  %call21 = call i8* @colprintLineGetColumn(%struct.colprintLine* %12, i32 1)
  store i8* %call21, i8** %a_name, align 8
  %13 = load %struct.colprintLine*, %struct.colprintLine** %b.addr, align 8
  %call22 = call i8* @colprintLineGetColumn(%struct.colprintLine* %13, i32 1)
  store i8* %call22, i8** %b_name, align 8
  %14 = load i8*, i8** %a_name, align 8
  %15 = load i8*, i8** %b_name, align 8
  %call23 = call i32 @strcmp(i8* %14, i8* %15)
  store i32 %call23, i32* %retval, align 4
  br label %return

if.else24:                                        ; preds = %land.lhs.true14, %if.else11
  %16 = load %struct.colprintLine*, %struct.colprintLine** %a.addr, align 8
  %call25 = call i8* @colprintLineGetColumn(%struct.colprintLine* %16, i32 0)
  store i8* %call25, i8** %a_letter, align 8
  %17 = load %struct.colprintLine*, %struct.colprintLine** %b.addr, align 8
  %call26 = call i8* @colprintLineGetColumn(%struct.colprintLine* %17, i32 0)
  store i8* %call26, i8** %b_letter, align 8
  %18 = load i8*, i8** %a_letter, align 8
  %19 = load i8*, i8** %b_letter, align 8
  %call27 = call i32 @strcmp(i8* %18, i8* %19)
  store i32 %call27, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else24, %if.end, %if.then20, %if.then10, %if.then
  %20 = load i32, i32* %retval, align 4
  ret i32 %20
}

declare void @colprintTablePrint(%struct.colprintTable*, i32, i1 zeroext, i1 zeroext, %struct.__sFILE*) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i1 @isXtagEnabled(i32 %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  %def = alloca %struct.sXtagDefinition*, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call %struct.sXtagDefinition* @getXtagDefinition(i32 %0)
  store %struct.sXtagDefinition* %call, %struct.sXtagDefinition** %def, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %1 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %isEnabled = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %1, i32 0, i32 4
  %2 = load i1 (%struct.sXtagDefinition*)*, i1 (%struct.sXtagDefinition*)** %isEnabled, align 8
  %tobool = icmp ne i1 (%struct.sXtagDefinition*)* %2, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %do.end
  %3 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %isEnabled1 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %3, i32 0, i32 4
  %4 = load i1 (%struct.sXtagDefinition*)*, i1 (%struct.sXtagDefinition*)** %isEnabled1, align 8
  %5 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %call2 = call zeroext i1 %4(%struct.sXtagDefinition* %5)
  store i1 %call2, i1* %retval, align 1
  br label %return

if.else:                                          ; preds = %do.end
  %6 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %enabled = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %6, i32 0, i32 0
  %7 = load i8, i8* %enabled, align 8
  %tobool3 = trunc i8 %7 to i1
  store i1 %tobool3, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load i1, i1* %retval, align 1
  ret i1 %8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i1 @isXtagFixed(i32 %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  %def = alloca %struct.sXtagDefinition*, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call %struct.sXtagDefinition* @getXtagDefinition(i32 %0)
  store %struct.sXtagDefinition* %call, %struct.sXtagDefinition** %def, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %1 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %isFixed = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %1, i32 0, i32 5
  %2 = load i1 (%struct.sXtagDefinition*)*, i1 (%struct.sXtagDefinition*)** %isFixed, align 8
  %tobool = icmp ne i1 (%struct.sXtagDefinition*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %3 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %isFixed1 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %3, i32 0, i32 5
  %4 = load i1 (%struct.sXtagDefinition*)*, i1 (%struct.sXtagDefinition*)** %isFixed1, align 8
  %5 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %call2 = call zeroext i1 %4(%struct.sXtagDefinition* %5)
  store i1 %call2, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %do.end
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i1, i1* %retval, align 1
  ret i1 %6
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i1 @enableXtag(i32 %type, i1 zeroext %state) #0 {
entry:
  %type.addr = alloca i32, align 4
  %state.addr = alloca i8, align 1
  %old = alloca i8, align 1
  %def = alloca %struct.sXtagDefinition*, align 8
  store i32 %type, i32* %type.addr, align 4
  %frombool = zext i1 %state to i8
  store i8 %frombool, i8* %state.addr, align 1
  %0 = load i32, i32* %type.addr, align 4
  %call = call %struct.sXtagDefinition* @getXtagDefinition(i32 %0)
  store %struct.sXtagDefinition* %call, %struct.sXtagDefinition** %def, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %1 = load i32, i32* %type.addr, align 4
  %call1 = call zeroext i1 @isXtagEnabled(i32 %1)
  %frombool2 = zext i1 %call1 to i8
  store i8 %frombool2, i8* %old, align 1
  %2 = load i32, i32* %type.addr, align 4
  %call3 = call zeroext i1 @isXtagFixed(i32 %2)
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %do.end
  %3 = load i8, i8* %old, align 1
  %tobool = trunc i8 %3 to i1
  %4 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %enabled = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %4, i32 0, i32 0
  %frombool4 = zext i1 %tobool to i8
  store i8 %frombool4, i8* %enabled, align 8
  br label %if.end

if.else:                                          ; preds = %do.end
  %5 = load i8, i8* %state.addr, align 1
  %tobool5 = trunc i8 %5 to i1
  %6 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %enabled6 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %6, i32 0, i32 0
  %frombool7 = zext i1 %tobool5 to i8
  store i8 %frombool7, i8* %enabled6, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %isEnabled = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %7, i32 0, i32 4
  store i1 (%struct.sXtagDefinition*)* null, i1 (%struct.sXtagDefinition*)** %isEnabled, align 8
  %8 = load i8, i8* %old, align 1
  %tobool8 = trunc i8 %8 to i1
  ret i1 %tobool8
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define zeroext i1 @isCommonXtag(i32 %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp slt i32 %0, 8
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 1, i32 0
  %tobool = icmp ne i32 %cond, 0
  ret i1 %tobool
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @getXtagOwner(i32 %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call %struct.sXtagObject* @getXtagObject(i32 %0)
  %language = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %call, i32 0, i32 1
  %1 = load i32, i32* %language, align 8
  ret i32 %1
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i8* @getXtagName(i32 %type) #0 {
entry:
  %retval = alloca i8*, align 8
  %type.addr = alloca i32, align 4
  %def = alloca %struct.sXtagDefinition*, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call %struct.sXtagDefinition* @getXtagDefinition(i32 %0)
  store %struct.sXtagDefinition* %call, %struct.sXtagDefinition** %def, align 8
  %1 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %tobool = icmp ne %struct.sXtagDefinition* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %name = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %2, i32 0, i32 2
  %3 = load i8*, i8** %name, align 8
  store i8* %3, i8** %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i8*, i8** %retval, align 8
  ret i8* %4
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define void @initXtagObjects() #0 {
entry:
  %xobj = alloca %struct.sXtagObject*, align 8
  %i = alloca i32, align 4
  store i32 0, i32* @xtagObjectUsed, align 4
  store i32 8, i32* @xtagObjectAllocated, align 4
  %0 = load i32, i32* @xtagObjectAllocated, align 4
  %conv = zext i32 %0 to i64
  %mul = mul i64 %conv, 16
  %call = call i8* @eMalloc(i64 %mul)
  %1 = bitcast i8* %call to %struct.sXtagObject*
  store %struct.sXtagObject* %1, %struct.sXtagObject** @xtagObjects, align 8
  %call1 = call i8* @trashBoxPut(%struct.sTrashBox* null, i8* bitcast (%struct.sXtagObject** @xtagObjects to i8*), void (i8*)* bitcast (void (i8**)* @eFreeIndirect to void (i8*)*))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %conv2 = zext i32 %2 to i64
  %cmp = icmp ult i64 %conv2, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.sXtagObject*, %struct.sXtagObject** @xtagObjects, align 8
  %4 = load i32, i32* %i, align 4
  %idx.ext = zext i32 %4 to i64
  %add.ptr = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %3, i64 %idx.ext
  store %struct.sXtagObject* %add.ptr, %struct.sXtagObject** %xobj, align 8
  %5 = load i32, i32* %i, align 4
  %idx.ext4 = zext i32 %5 to i64
  %add.ptr5 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* getelementptr inbounds ([8 x %struct.sXtagDefinition], [8 x %struct.sXtagDefinition]* @xtagDefinitions, i64 0, i64 0), i64 %idx.ext4
  %6 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %def = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %6, i32 0, i32 0
  store %struct.sXtagDefinition* %add.ptr5, %struct.sXtagDefinition** %def, align 8
  %7 = load i32, i32* %i, align 4
  %8 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %def6 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %8, i32 0, i32 0
  %9 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def6, align 8
  %xtype = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %9, i32 0, i32 6
  store i32 %7, i32* %xtype, align 8
  %10 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %language = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %10, i32 0, i32 1
  store i32 -2, i32* %language, align 8
  %11 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %sibling = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %11, i32 0, i32 2
  store i32 -1, i32* %sibling, align 4
  %12 = load i32, i32* @xtagObjectUsed, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* @xtagObjectUsed, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, i32* %i, align 4
  %inc7 = add i32 %13, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare i8* @eMalloc(i64) #1

declare i8* @trashBoxPut(%struct.sTrashBox*, i8*, void (i8*)*) #1

declare void @eFreeIndirect(i8**) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @countXtags() #0 {
entry:
  %0 = load i32, i32* @xtagObjectUsed, align 4
  ret i32 %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @defineXtag(%struct.sXtagDefinition* %def, i32 %language) #0 {
entry:
  %def.addr = alloca %struct.sXtagDefinition*, align 8
  %language.addr = alloca i32, align 4
  %xobj = alloca %struct.sXtagObject*, align 8
  %i = alloca i64, align 8
  store %struct.sXtagDefinition* %def, %struct.sXtagDefinition** %def.addr, align 8
  store i32 %language, i32* %language.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body1

do.body1:                                         ; preds = %do.end
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end2
  %0 = load i64, i64* %i, align 8
  %1 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %name = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %1, i32 0, i32 2
  %2 = load i8*, i8** %name, align 8
  %call = call i64 @strlen(i8* %2)
  %cmp = icmp ult i64 %0, %call
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body3

do.body3:                                         ; preds = %for.body
  br label %do.end4

do.end4:                                          ; preds = %do.body3
  br label %for.inc

for.inc:                                          ; preds = %do.end4
  %3 = load i64, i64* %i, align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %4 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %letter = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %4, i32 0, i32 1
  store i8 0, i8* %letter, align 1
  %5 = load i32, i32* @xtagObjectUsed, align 4
  %6 = load i32, i32* @xtagObjectAllocated, align 4
  %cmp5 = icmp eq i32 %5, %6
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %7 = load i32, i32* @xtagObjectAllocated, align 4
  %mul = mul i32 %7, 2
  store i32 %mul, i32* @xtagObjectAllocated, align 4
  %8 = load %struct.sXtagObject*, %struct.sXtagObject** @xtagObjects, align 8
  %9 = bitcast %struct.sXtagObject* %8 to i8*
  %10 = load i32, i32* @xtagObjectAllocated, align 4
  %conv = zext i32 %10 to i64
  %mul6 = mul i64 %conv, 16
  %call7 = call i8* @eRealloc(i8* %9, i64 %mul6)
  %11 = bitcast i8* %call7 to %struct.sXtagObject*
  store %struct.sXtagObject* %11, %struct.sXtagObject** @xtagObjects, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %12 = load %struct.sXtagObject*, %struct.sXtagObject** @xtagObjects, align 8
  %13 = load i32, i32* @xtagObjectUsed, align 4
  %idx.ext = zext i32 %13 to i64
  %add.ptr = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %12, i64 %idx.ext
  store %struct.sXtagObject* %add.ptr, %struct.sXtagObject** %xobj, align 8
  %14 = load i32, i32* @xtagObjectUsed, align 4
  %inc8 = add i32 %14, 1
  store i32 %inc8, i32* @xtagObjectUsed, align 4
  %15 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %xtype = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %15, i32 0, i32 6
  store i32 %14, i32* %xtype, align 8
  %16 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %17 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %def9 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %17, i32 0, i32 0
  store %struct.sXtagDefinition* %16, %struct.sXtagDefinition** %def9, align 8
  %18 = load i32, i32* %language.addr, align 4
  %19 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %language10 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %19, i32 0, i32 1
  store i32 %18, i32* %language10, align 8
  %20 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %sibling = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %20, i32 0, i32 2
  store i32 -1, i32* %sibling, align 4
  %21 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %xtype11 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %21, i32 0, i32 6
  %22 = load i32, i32* %xtype11, align 8
  %23 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %name12 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %23, i32 0, i32 2
  %24 = load i8*, i8** %name12, align 8
  call void @updateSiblingXtag(i32 %22, i8* %24)
  %25 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %xtype13 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %25, i32 0, i32 6
  %26 = load i32, i32* %xtype13, align 8
  %27 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %name14 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %27, i32 0, i32 2
  %28 = load i8*, i8** %name14, align 8
  %29 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %description = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %29, i32 0, i32 3
  %30 = load i8*, i8** %description, align 8
  %31 = load i32, i32* %language.addr, align 4
  %call15 = call i8* @getLanguageName(i32 %31)
  call void (i8*, ...) @verbose(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.6, i64 0, i64 0), i32 %26, i8* %28, i8* %30, i8* %call15)
  %32 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def.addr, align 8
  %xtype16 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %32, i32 0, i32 6
  %33 = load i32, i32* %xtype16, align 8
  ret i32 %33
}

declare i64 @strlen(i8*) #1

declare i8* @eRealloc(i8*, i64) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal void @updateSiblingXtag(i32 %type, i8* %name) #0 {
entry:
  %type.addr = alloca i32, align 4
  %name.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %xobj = alloca %struct.sXtagObject*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i8* %name, i8** %name.addr, align 8
  %0 = load i32, i32* %type.addr, align 4
  store i32 %0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.sXtagObject*, %struct.sXtagObject** @xtagObjects, align 8
  %3 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %2, i64 %idx.ext
  %add.ptr1 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %add.ptr, i64 -1
  store %struct.sXtagObject* %add.ptr1, %struct.sXtagObject** %xobj, align 8
  %4 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %def = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %4, i32 0, i32 0
  %5 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def, align 8
  %name2 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %5, i32 0, i32 2
  %6 = load i8*, i8** %name2, align 8
  %tobool = icmp ne i8* %6, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %7 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %def3 = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %7, i32 0, i32 0
  %8 = load %struct.sXtagDefinition*, %struct.sXtagDefinition** %def3, align 8
  %name4 = getelementptr inbounds %struct.sXtagDefinition, %struct.sXtagDefinition* %8, i32 0, i32 2
  %9 = load i8*, i8** %name4, align 8
  %10 = load i8*, i8** %name.addr, align 8
  %call = call i32 @strcmp(i8* %9, i8* %10)
  %cmp5 = icmp eq i32 %call, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %do.body
  %11 = load i32, i32* %type.addr, align 4
  %12 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %sibling = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %12, i32 0, i32 2
  store i32 %11, i32* %sibling, align 4
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load i32, i32* %i, align 4
  %dec = add nsw i32 %13, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %do.end, %for.cond
  ret void
}

declare void @verbose(i8*, ...) #1

declare i8* @getLanguageName(i32) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @nextSiblingXtag(i32 %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  %xobj = alloca %struct.sXtagObject*, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.sXtagObject*, %struct.sXtagObject** @xtagObjects, align 8
  %1 = load i32, i32* %type.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %0, i64 %idx.ext
  store %struct.sXtagObject* %add.ptr, %struct.sXtagObject** %xobj, align 8
  %2 = load %struct.sXtagObject*, %struct.sXtagObject** %xobj, align 8
  %sibling = getelementptr inbounds %struct.sXtagObject, %struct.sXtagObject* %2, i32 0, i32 2
  %3 = load i32, i32* %sibling, align 4
  ret i32 %3
}

declare void @initializeParser(i32) #1

declare i32 @strcmp(i8*, i8*) #1

declare %struct.colprintLine* @colprintTableGetNewLine(%struct.colprintTable*) #1

declare void @colprintLineAppendColumnChar(%struct.colprintLine*, i8 signext) #1

declare void @colprintLineAppendColumnCString(%struct.colprintLine*, i8*) #1

declare void @colprintLineAppendColumnBool(%struct.colprintLine*, i1 zeroext) #1

declare i8* @colprintLineGetColumn(%struct.colprintLine*, i32) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @isPseudoTagsEnabled(%struct.sXtagDefinition* %pdef) #0 {
entry:
  %retval = alloca i1, align 1
  %pdef.addr = alloca %struct.sXtagDefinition*, align 8
  store %struct.sXtagDefinition* %pdef, %struct.sXtagDefinition** %pdef.addr, align 8
  %call = call zeroext i1 @writerCanPrintPtag()
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call zeroext i1 @isDestinationStdout()
  %lnot = xor i1 %call1, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %0 = load i1, i1* %retval, align 1
  ret i1 %0
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define internal zeroext i1 @isPseudoTagsFixed(%struct.sXtagDefinition* %pdef) #0 {
entry:
  %retval = alloca i1, align 1
  %pdef.addr = alloca %struct.sXtagDefinition*, align 8
  store %struct.sXtagDefinition* %pdef, %struct.sXtagDefinition** %pdef.addr, align 8
  %call = call zeroext i1 @writerCanPrintPtag()
  br i1 %call, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.else:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.else, %if.then
  %0 = load i1, i1* %retval, align 1
  ret i1 %0
}

declare zeroext i1 @writerCanPrintPtag() #1

declare zeroext i1 @isDestinationStdout() #1

attributes #0 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="cyclone" "target-features"="+aes,+crypto,+fp-armv8,+neon,+sha2,+zcm,+zcz" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="cyclone" "target-features"="+aes,+crypto,+fp-armv8,+neon,+sha2,+zcm,+zcz" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!"clang version 10.0.0 (https://github.com/holzschu/clang.git 0cfc630fbdb62e96720b611a57123ef3eb13e297) (https://github.com/holzschu/llvm.git 0d8a71e39b28502c24718f7e74b5acbcfe36dfe0)"}
